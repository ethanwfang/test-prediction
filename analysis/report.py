"""
Report generation for Kalshi market analysis.

Supports both Markdown and self-contained HTML output.
"""

from datetime import datetime
from pathlib import Path

import pandas as pd

from stats import market_summary, outcome_analysis, trading_patterns
from charts import generate_charts_base64


# HTML template with embedded CSS
HTML_TEMPLATE = '''<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Kalshi Market Analysis Report</title>
    <style>
        * {{ box-sizing: border-box; }}
        body {{
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #fafafa;
            color: #1f2937;
        }}
        h1 {{
            color: #1e3a5f;
            border-bottom: 3px solid #2563eb;
            padding-bottom: 10px;
        }}
        h2 {{
            color: #2563eb;
            border-bottom: 2px solid #e5e7eb;
            padding-bottom: 8px;
            margin-top: 40px;
        }}
        h3 {{
            color: #374151;
            margin-top: 25px;
        }}
        table {{
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
            background: white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }}
        th, td {{
            border: 1px solid #e5e7eb;
            padding: 12px;
            text-align: left;
        }}
        th {{
            background: #f8fafc;
            font-weight: 600;
        }}
        tr:hover {{
            background: #f8fafc;
        }}
        img {{
            max-width: 100%;
            height: auto;
            margin: 20px 0;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }}
        .metric {{
            display: inline-block;
            background: #f0f9ff;
            padding: 8px 16px;
            margin: 4px;
            border-radius: 6px;
            border-left: 3px solid #2563eb;
        }}
        .metric-label {{
            font-size: 0.85em;
            color: #6b7280;
        }}
        .metric-value {{
            font-size: 1.1em;
            font-weight: 600;
            color: #1e3a5f;
        }}
        .yes {{ color: #16a34a; font-weight: bold; }}
        .no {{ color: #dc2626; font-weight: bold; }}
        .summary-box {{
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            margin: 20px 0;
        }}
        .insight {{
            background: #fef3c7;
            border-left: 4px solid #f59e0b;
            padding: 12px 16px;
            margin: 10px 0;
            border-radius: 0 6px 6px 0;
        }}
        .deep-dive {{
            background: white;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            margin: 30px 0;
        }}
        .deep-dive h3 {{
            margin-top: 0;
            color: #1e3a5f;
        }}
        .narrative {{
            background: #f0fdf4;
            border-left: 4px solid #16a34a;
            padding: 15px 20px;
            margin: 15px 0;
            border-radius: 0 6px 6px 0;
            font-style: italic;
        }}
        .footer {{
            margin-top: 50px;
            padding-top: 20px;
            border-top: 1px solid #e5e7eb;
            color: #6b7280;
            font-size: 0.9em;
        }}
        .chart-container {{
            text-align: center;
            margin: 25px 0;
        }}
        .metrics-grid {{
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }}
    </style>
</head>
<body>
{content}
<div class="footer">
    <p>Report generated by Kalshi Market Analysis Pipeline</p>
    <p>Generated: {timestamp}</p>
</div>
</body>
</html>'''


def generate_html_report(
    market_info: pd.DataFrame,
    candlesticks: pd.DataFrame,
    trades: pd.DataFrame,
    deep_dives: list[dict] = None,
    output_path: str = None,
    top_n: int = 5
) -> str:
    """
    Generate a self-contained HTML report with embedded images.

    Args:
        market_info: Market info DataFrame
        candlesticks: Candlesticks DataFrame
        trades: Trades DataFrame
        deep_dives: List of deep dive dictionaries (from deep_dive.py)
        output_path: Path to save HTML file
        top_n: Number of top markets to feature

    Returns:
        Path to generated report
    """
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    # Gather statistics
    summary = market_summary(market_info)
    outcomes = outcome_analysis(market_info)
    patterns = trading_patterns(trades)

    # Generate charts as base64
    print("  Generating charts...")
    charts = generate_charts_base64(market_info, candlesticks, top_n=top_n)

    # Build HTML sections
    sections = []

    # Header
    sections.append('<h1>Kalshi Market Analysis Report</h1>')

    # Executive Summary
    sections.append(_generate_summary_section(summary, outcomes, patterns))

    # Top Markets Table
    sections.append(_generate_top_markets_section(summary))

    # Volume Chart
    if 'volume_ranking' in charts:
        sections.append('<h2>Market Volume Distribution</h2>')
        sections.append(f'<div class="chart-container"><img src="data:image/png;base64,{charts["volume_ranking"]}" alt="Volume Ranking"></div>')

    # Outcome Analysis
    if outcomes.get('finalized_count', 0) > 0:
        sections.append(_generate_outcome_section(outcomes, charts))

    # Deep Dives
    if deep_dives:
        sections.append('<h2>Deep Dive Analysis</h2>')
        for dive in deep_dives:
            sections.append(_generate_deep_dive_section(dive))

    # Price History for Top Markets
    sections.append(_generate_price_history_section(market_info, charts, top_n))

    # Key Insights
    sections.append(_generate_insights_section(summary, outcomes, patterns, deep_dives))

    # Combine content
    content = '\n'.join(sections)
    html = HTML_TEMPLATE.format(content=content, timestamp=timestamp)

    # Write file
    if output_path:
        Path(output_path).parent.mkdir(parents=True, exist_ok=True)
        Path(output_path).write_text(html)
        return output_path

    return html


def _generate_summary_section(summary: dict, outcomes: dict, patterns: dict) -> str:
    """Generate executive summary section."""
    lines = ['<h2>Executive Summary</h2>', '<div class="summary-box">']

    metrics = []

    if 'total_markets' in summary:
        metrics.append(f'<div class="metric"><span class="metric-label">Markets Analyzed</span><br><span class="metric-value">{summary["total_markets"]:,}</span></div>')

    if 'total_volume' in summary:
        metrics.append(f'<div class="metric"><span class="metric-label">Total Volume</span><br><span class="metric-value">{summary["total_volume"]:,} contracts</span></div>')

    if 'by_status' in summary:
        active = summary['by_status'].get('active', 0)
        finalized = summary['by_status'].get('finalized', 0)
        metrics.append(f'<div class="metric"><span class="metric-label">Active / Finalized</span><br><span class="metric-value">{active} / {finalized}</span></div>')

    if outcomes.get('finalized_count', 0) > 0:
        yes_count = outcomes.get('resolved_yes', 0)
        no_count = outcomes.get('resolved_no', 0)
        metrics.append(f'<div class="metric"><span class="metric-label">Outcomes</span><br><span class="metric-value"><span class="yes">{yes_count} YES</span> / <span class="no">{no_count} NO</span></span></div>')

    if patterns.get('total_trades'):
        metrics.append(f'<div class="metric"><span class="metric-label">Total Trades</span><br><span class="metric-value">{patterns["total_trades"]:,}</span></div>')

    if patterns.get('avg_trade_size'):
        metrics.append(f'<div class="metric"><span class="metric-label">Avg Trade Size</span><br><span class="metric-value">{patterns["avg_trade_size"]:.1f} contracts</span></div>')

    lines.append('<div class="metrics-grid">')
    lines.extend(metrics)
    lines.append('</div></div>')

    return '\n'.join(lines)


def _generate_top_markets_section(summary: dict) -> str:
    """Generate top markets table."""
    if 'top_by_volume' not in summary or not summary['top_by_volume']:
        return ''

    lines = [
        '<h2>Top Markets by Volume</h2>',
        '<table>',
        '<tr><th>Rank</th><th>Ticker</th><th>Title</th><th>Volume</th><th>Outcome</th></tr>'
    ]

    for i, market in enumerate(summary['top_by_volume'], 1):
        ticker = market.get('ticker', 'N/A')
        title = market.get('title', 'N/A')
        if len(title) > 60:
            title = title[:57] + '...'
        volume = market.get('volume', 0)
        result = market.get('result', '-')

        if result and isinstance(result, str) and result in ('yes', 'no'):
            result_html = f'<span class="{result}">{result.upper()}</span>'
        else:
            result_html = '-'

        lines.append(f'<tr><td>{i}</td><td><code>{ticker}</code></td><td>{title}</td><td>{volume:,}</td><td>{result_html}</td></tr>')

    lines.append('</table>')
    return '\n'.join(lines)


def _generate_outcome_section(outcomes: dict, charts: dict) -> str:
    """Generate outcome analysis section."""
    lines = ['<h2>Outcome Analysis</h2>']

    # Outcome pie chart
    if 'outcomes' in charts:
        lines.append(f'<div class="chart-container"><img src="data:image/png;base64,{charts["outcomes"]}" alt="Outcome Distribution"></div>')

    # Statistics
    lines.append('<h3>Outcome Statistics</h3>')
    lines.append('<div class="metrics-grid">')

    lines.append(f'<div class="metric"><span class="metric-label">Resolved YES</span><br><span class="metric-value yes">{outcomes.get("resolved_yes", 0)}</span></div>')
    lines.append(f'<div class="metric"><span class="metric-label">Resolved NO</span><br><span class="metric-value no">{outcomes.get("resolved_no", 0)}</span></div>')

    if 'avg_price_resolved_yes' in outcomes:
        lines.append(f'<div class="metric"><span class="metric-label">Avg YES Final Price</span><br><span class="metric-value">{outcomes["avg_price_resolved_yes"]:.1f}\u00a2</span></div>')

    if 'avg_price_resolved_no' in outcomes:
        lines.append(f'<div class="metric"><span class="metric-label">Avg NO Final Price</span><br><span class="metric-value">{outcomes["avg_price_resolved_no"]:.1f}\u00a2</span></div>')

    lines.append('</div>')

    # Calibration chart
    if 'calibration' in charts:
        lines.append('<h3>Market Calibration</h3>')
        lines.append('<p>This chart shows how well market prices predicted actual outcomes. Points near the diagonal line indicate good calibration.</p>')
        lines.append(f'<div class="chart-container"><img src="data:image/png;base64,{charts["calibration"]}" alt="Calibration"></div>')

    return '\n'.join(lines)


def _generate_deep_dive_section(dive: dict) -> str:
    """Generate a deep dive section for a market group."""
    lines = ['<div class="deep-dive">']

    # Title
    title = dive.get('title', dive.get('event_ticker', 'Market Group'))
    lines.append(f'<h3>{title}</h3>')

    # Basic info
    lines.append('<div class="metrics-grid">')
    lines.append(f'<div class="metric"><span class="metric-label">Markets in Group</span><br><span class="metric-value">{dive.get("market_count", 0)}</span></div>')
    lines.append(f'<div class="metric"><span class="metric-label">Total Volume</span><br><span class="metric-value">{dive.get("total_volume", 0):,}</span></div>')

    if dive.get('winner'):
        lines.append(f'<div class="metric"><span class="metric-label">Winner</span><br><span class="metric-value yes">{dive["winner"]}</span></div>')

    # Convergence metrics
    if dive.get('convergence_metrics'):
        m = dive['convergence_metrics']
        if m.get('crossed_50_date'):
            lines.append(f'<div class="metric"><span class="metric-label">Crossed 50%</span><br><span class="metric-value">{m["crossed_50_date"]}</span></div>')
        if m.get('crossed_90_date'):
            lines.append(f'<div class="metric"><span class="metric-label">Crossed 90%</span><br><span class="metric-value">{m["crossed_90_date"]}</span></div>')
        if m.get('days_at_90_plus'):
            lines.append(f'<div class="metric"><span class="metric-label">Days at 90%+</span><br><span class="metric-value">{m["days_at_90_plus"]}</span></div>')

    lines.append('</div>')

    # Narrative
    if dive.get('narrative'):
        lines.append(f'<div class="narrative">{dive["narrative"]}</div>')

    # Probability distribution chart
    if dive.get('probability_chart'):
        lines.append(f'<div class="chart-container"><img src="data:image/png;base64,{dive["probability_chart"]}" alt="Probability Distribution"></div>')

    # Convergence chart
    if dive.get('convergence_chart'):
        lines.append(f'<div class="chart-container"><img src="data:image/png;base64,{dive["convergence_chart"]}" alt="Convergence Analysis"></div>')

    lines.append('</div>')
    return '\n'.join(lines)


def _generate_price_history_section(market_info: pd.DataFrame, charts: dict, top_n: int) -> str:
    """Generate price history charts for top markets."""
    # Filter to charts that are individual price charts
    price_charts = {k: v for k, v in charts.items() if k.startswith('price_')}

    if not price_charts:
        return ''

    lines = ['<h2>Price History - Top Markets</h2>']

    top_markets = market_info.nlargest(top_n, 'volume')

    for _, market in top_markets.iterrows():
        ticker = market['ticker']
        chart_key = f'price_{ticker}'

        if chart_key not in charts:
            continue

        title = market.get('title', ticker)
        volume = market.get('volume', 0)
        result = market.get('result', None)

        lines.append('<div style="margin: 30px 0;">')
        lines.append(f'<h3>{title}</h3>')
        lines.append(f'<p><strong>Ticker:</strong> <code>{ticker}</code> | <strong>Volume:</strong> {volume:,} contracts')

        if result and isinstance(result, str) and result in ('yes', 'no'):
            result_class = result
            lines.append(f' | <strong>Outcome:</strong> <span class="{result_class}">{result.upper()}</span>')

        lines.append('</p>')
        lines.append(f'<div class="chart-container"><img src="data:image/png;base64,{charts[chart_key]}" alt="{ticker}"></div>')
        lines.append('</div>')

    return '\n'.join(lines)


def _generate_insights_section(summary: dict, outcomes: dict, patterns: dict, deep_dives: list = None) -> str:
    """Generate key insights section."""
    lines = ['<h2>Key Insights</h2>']

    insights = []

    # Insight: Most traded market
    if 'top_by_volume' in summary and summary['top_by_volume']:
        top_market = summary['top_by_volume'][0]
        insights.append(
            f"The most actively traded market was <strong>{top_market['ticker']}</strong> "
            f"with {top_market['volume']:,} contracts traded."
        )

    # Insight: Outcome distribution
    if outcomes.get('finalized_count', 0) > 0:
        yes_count = outcomes.get('resolved_yes', 0)
        no_count = outcomes.get('resolved_no', 0)
        total = yes_count + no_count
        if total > 0:
            yes_pct = yes_count / total * 100
            if yes_pct > 60:
                insights.append(f"Markets favored YES outcomes ({yes_pct:.0f}% resolved YES).")
            elif yes_pct < 40:
                insights.append(f"Markets favored NO outcomes ({100-yes_pct:.0f}% resolved NO).")
            else:
                insights.append(f"Outcomes were roughly balanced ({yes_pct:.0f}% YES, {100-yes_pct:.0f}% NO).")

    # Insight: Trading activity
    if patterns.get('total_contracts', 0) > 0:
        avg_size = patterns.get('avg_trade_size', 0)
        if avg_size > 10:
            insights.append(f"Trading activity showed larger position sizes (avg {avg_size:.1f} contracts per trade).")
        else:
            insights.append(f"Trading activity consisted of smaller, retail-sized trades (avg {avg_size:.1f} contracts).")

    # Insights from deep dives
    if deep_dives:
        for dive in deep_dives:
            metrics = dive.get('convergence_metrics') or {}
            if metrics.get('days_at_90_plus'):
                days = metrics['days_at_90_plus']
                if days > 30:
                    months = days // 30
                    insights.append(
                        f"<strong>{dive['title']}</strong> markets converged to the correct answer "
                        f"~{months} month(s) before official resolution."
                    )

    for insight in insights:
        lines.append(f'<div class="insight">{insight}</div>')

    return '\n'.join(lines)


def generate_markdown_report(
    market_info: pd.DataFrame,
    candlesticks: pd.DataFrame,
    trades: pd.DataFrame,
    output_dir: str,
    top_n: int = 10
) -> str:
    """
    Generate a markdown report (legacy format).

    For backwards compatibility with existing workflow.
    """
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    report_date = datetime.now().strftime("%Y%m%d")

    # Gather statistics
    summary = market_summary(market_info)
    outcomes = outcome_analysis(market_info)
    patterns = trading_patterns(trades)

    # Build report content
    lines = []

    # Header
    lines.append("# Kalshi Market Analysis Report")
    lines.append(f"\n**Generated:** {timestamp}\n")

    # Executive Summary
    lines.append("## Executive Summary\n")
    lines.append(f"- **Total Markets Analyzed:** {summary.get('total_markets', 0):,}")
    lines.append(f"- **Total Trading Volume:** {summary.get('total_volume', 0):,} contracts")

    if 'by_status' in summary:
        status_str = ", ".join(f"{v} {k}" for k, v in summary['by_status'].items())
        lines.append(f"- **Market Status:** {status_str}")

    if outcomes.get('finalized_count', 0) > 0:
        lines.append(f"- **Finalized Markets:** {outcomes['finalized_count']} ({outcomes.get('finalized_pct', 0):.1f}%)")
        if 'resolved_yes' in outcomes:
            lines.append(f"- **Outcomes:** {outcomes.get('resolved_yes', 0)} YES, {outcomes.get('resolved_no', 0)} NO")

    if 'earliest_market' in summary:
        lines.append(f"- **Date Range:** {summary['earliest_market'][:10]} to {summary['latest_market'][:10]}")

    lines.append("")

    # Top Markets Table
    if 'top_by_volume' in summary and summary['top_by_volume']:
        lines.append("## Top Markets by Volume\n")
        lines.append("| Rank | Ticker | Title | Volume | Outcome |")
        lines.append("|------|--------|-------|--------|---------|")

        for i, market in enumerate(summary['top_by_volume'], 1):
            ticker = market.get('ticker', 'N/A')
            title = market.get('title', 'N/A')
            if len(title) > 50:
                title = title[:47] + '...'
            volume = market.get('volume', 0)
            result = market.get('result', '-')
            if result and isinstance(result, str) and result != '-':
                result = result.upper()
            elif not isinstance(result, str):
                result = '-'
            lines.append(f"| {i} | {ticker} | {title} | {volume:,} | {result} |")

        lines.append("")

    # Volume Ranking Chart
    lines.append("## Market Volume Distribution\n")
    lines.append("![Volume Ranking](charts/volume_ranking.png)\n")

    # Outcome Analysis
    if outcomes.get('finalized_count', 0) > 0:
        lines.append("## Outcome Analysis\n")
        lines.append("![Outcome Distribution](charts/outcomes.png)\n")

        lines.append("### Outcome Statistics\n")
        lines.append(f"- Markets resolved **YES**: {outcomes.get('resolved_yes', 0)}")
        lines.append(f"- Markets resolved **NO**: {outcomes.get('resolved_no', 0)}")

        if 'avg_price_resolved_yes' in outcomes:
            lines.append(f"- Average final price of YES-resolved markets: {outcomes['avg_price_resolved_yes']:.1f} cents")
        if 'avg_price_resolved_no' in outcomes:
            lines.append(f"- Average final price of NO-resolved markets: {outcomes['avg_price_resolved_no']:.1f} cents")

        lines.append("")

        # Calibration
        lines.append("### Market Calibration\n")
        lines.append("This chart shows how well market prices predicted actual outcomes. ")
        lines.append("Points near the diagonal line indicate good calibration.\n")
        lines.append("![Calibration](charts/calibration.png)\n")

    # Trading Patterns
    if patterns:
        lines.append("## Trading Patterns\n")
        lines.append(f"- **Total Trades:** {patterns.get('total_trades', 0):,}")
        lines.append(f"- **Total Contracts Traded:** {patterns.get('total_contracts', 0):,}")
        lines.append(f"- **Average Trade Size:** {patterns.get('avg_trade_size', 0):.1f} contracts")
        lines.append(f"- **Median Trade Size:** {patterns.get('median_trade_size', 0):.0f} contracts")
        lines.append(f"- **Largest Single Trade:** {patterns.get('max_trade_size', 0):,} contracts")

        if 'yes_taker_pct' in patterns:
            lines.append(f"\n### Taker Side Analysis")
            lines.append(f"- YES taker volume: {patterns.get('yes_taker_volume', 0):,} ({patterns['yes_taker_pct']:.1f}%)")
            lines.append(f"- NO taker volume: {patterns.get('no_taker_volume', 0):,} ({100 - patterns['yes_taker_pct']:.1f}%)")

        lines.append("")

    # Price History for Top Markets
    if not market_info.empty and not candlesticks.empty:
        lines.append("## Price History - Top Markets\n")

        top_markets = market_info.nlargest(min(top_n, 5), 'volume')
        for _, market in top_markets.iterrows():
            ticker = market['ticker']
            title = market.get('title', ticker)
            volume = market.get('volume', 0)
            result = market.get('result', None)

            lines.append(f"### {title}\n")
            lines.append(f"**Ticker:** {ticker} | **Volume:** {volume:,} contracts")
            if result:
                lines.append(f" | **Outcome:** {result.upper()}")
            lines.append(f"\n\n![{ticker}](charts/{ticker}.png)\n")

    # Key Insights
    lines.append("## Key Insights\n")

    insights = []

    if 'top_by_volume' in summary and summary['top_by_volume']:
        top_market = summary['top_by_volume'][0]
        insights.append(f"The most actively traded market was **{top_market['ticker']}** "
                       f"with {top_market['volume']:,} contracts traded.")

    if outcomes.get('finalized_count', 0) > 0:
        yes_count = outcomes.get('resolved_yes', 0)
        no_count = outcomes.get('resolved_no', 0)
        total = yes_count + no_count
        if total > 0:
            yes_pct = yes_count / total * 100
            if yes_pct > 60:
                insights.append(f"Markets favored YES outcomes ({yes_pct:.0f}% resolved YES).")
            elif yes_pct < 40:
                insights.append(f"Markets favored NO outcomes ({100-yes_pct:.0f}% resolved NO).")
            else:
                insights.append(f"Outcomes were roughly balanced ({yes_pct:.0f}% YES, {100-yes_pct:.0f}% NO).")

    if patterns.get('total_contracts', 0) > 0:
        avg_size = patterns.get('avg_trade_size', 0)
        if avg_size > 10:
            insights.append(f"Trading activity showed larger position sizes (avg {avg_size:.1f} contracts per trade).")
        else:
            insights.append(f"Trading activity consisted of smaller, retail-sized trades (avg {avg_size:.1f} contracts).")

    for i, insight in enumerate(insights, 1):
        lines.append(f"{i}. {insight}")

    lines.append("")

    # Footer
    lines.append("---")
    lines.append(f"\n*Report generated by Kalshi Market Analysis Pipeline*")

    # Write report
    report_content = "\n".join(lines)
    reports_dir = Path(output_dir) / 'reports'
    reports_dir.mkdir(parents=True, exist_ok=True)

    report_path = reports_dir / f'analysis_{report_date}.md'
    report_path.write_text(report_content)

    return str(report_path)


# Keep legacy function name for backwards compatibility
def generate_report(
    market_info: pd.DataFrame,
    candlesticks: pd.DataFrame,
    trades: pd.DataFrame,
    output_dir: str,
    top_n: int = 10
) -> str:
    """Legacy function - generates markdown report."""
    return generate_markdown_report(market_info, candlesticks, trades, output_dir, top_n)
